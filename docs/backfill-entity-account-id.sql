-- Backfill ENTITY_ACCOUNT_ID for distribution tables using mapping presets.
-- Assumes these columns have been added:
--   ml.ENTITY_SCOA_DISTRIBUTION.ENTITY_ACCOUNT_ID
--   ml.ENTITY_DISTRIBUTION_PRESETS.ENTITY_ACCOUNT_ID
--
-- The backfill uses:
--   ml.ENTITY_ACCOUNT_MAPPING (ENTITY_ACCOUNT_ID, PRESET_GUID, ENTITY_ID)
--   ml.ENTITY_MAPPING_PRESET_DETAIL (PRESET_GUID, TARGET_DATAPOINT)
-- to map GL (ENTITY_ACCOUNT_ID) -> SCoA (TARGET_DATAPOINT).
--
-- Updates only when the mapping is unambiguous for an entity + SCoA pair.
BEGIN TRAN;

IF OBJECT_ID('tempdb..#MappingBase') IS NOT NULL
  DROP TABLE #MappingBase;

IF OBJECT_ID('tempdb..#MappingAgg') IS NOT NULL
  DROP TABLE #MappingAgg;

CREATE TABLE #MappingBase (
  ENTITY_ID varchar(36) NOT NULL,
  ENTITY_ACCOUNT_ID varchar(100) NOT NULL,
  PRESET_GUID varchar(36) NULL,
  UPDATED_DTTM datetime NULL,
  SCOA_ACCOUNT_ID varchar(max) NULL
);

DECLARE @presetColumn sysname;
DECLARE @updatedColumn sysname;

SELECT TOP 1 @presetColumn = COLUMN_NAME
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'ml'
  AND TABLE_NAME = 'ENTITY_ACCOUNT_MAPPING'
  AND COLUMN_NAME IN ('PRESET_GUID', 'PRESET_ID', 'PRESETID');

SELECT TOP 1 @updatedColumn = COLUMN_NAME
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'ml'
  AND TABLE_NAME = 'ENTITY_ACCOUNT_MAPPING'
  AND COLUMN_NAME IN ('UPDATED_DTTM', 'UPDATED_AT', 'UPDATED_DATE');

IF @presetColumn IS NULL
BEGIN
  RAISERROR('ENTITY_ACCOUNT_MAPPING does not contain a preset GUID column (expected PRESET_GUID/PRESET_ID).', 16, 1);
  RETURN;
END;

DECLARE @mappingSql nvarchar(max) = N'
INSERT INTO #MappingBase (
  ENTITY_ID,
  ENTITY_ACCOUNT_ID,
  PRESET_GUID,
  UPDATED_DTTM,
  SCOA_ACCOUNT_ID
)
SELECT DISTINCT
  eam.ENTITY_ID,
  eam.ENTITY_ACCOUNT_ID,
  eam.' + QUOTENAME(@presetColumn) + N' AS PRESET_GUID,' +
  CASE
    WHEN @updatedColumn IS NULL THEN N' NULL AS UPDATED_DTTM,'
    ELSE N' eam.' + QUOTENAME(@updatedColumn) + N' AS UPDATED_DTTM,'
  END + N'
  NULLIF(LTRIM(RTRIM(emd.TARGET_DATAPOINT)), '''') AS SCOA_ACCOUNT_ID
FROM ml.ENTITY_ACCOUNT_MAPPING eam
INNER JOIN ml.ENTITY_MAPPING_PRESET_DETAIL emd
  ON emd.PRESET_GUID = eam.' + QUOTENAME(@presetColumn) + N'
WHERE eam.ENTITY_ACCOUNT_ID IS NOT NULL
  AND emd.TARGET_DATAPOINT IS NOT NULL;';

EXEC sp_executesql @mappingSql;

SELECT
  ENTITY_ID,
  SCOA_ACCOUNT_ID,
  MIN(ENTITY_ACCOUNT_ID) AS ENTITY_ACCOUNT_ID,
  COUNT(DISTINCT ENTITY_ACCOUNT_ID) AS ACCOUNT_COUNT
INTO #MappingAgg
FROM #MappingBase
WHERE SCOA_ACCOUNT_ID IS NOT NULL
GROUP BY ENTITY_ID, SCOA_ACCOUNT_ID;
UPDATE esd
SET esd.ENTITY_ACCOUNT_ID = ma.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
INNER JOIN #MappingAgg ma
  ON ma.ENTITY_ID = esd.ENTITY_ID
  AND ma.SCOA_ACCOUNT_ID = esd.SCOA_ACCOUNT_ID
WHERE esd.ENTITY_ACCOUNT_ID IS NULL
  AND ma.ACCOUNT_COUNT = 1;

UPDATE edp
SET edp.ENTITY_ACCOUNT_ID = ma.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
INNER JOIN #MappingAgg ma
  ON ma.ENTITY_ID = edp.ENTITY_ID
  AND ma.SCOA_ACCOUNT_ID = edp.SCOA_ACCOUNT_ID
WHERE edp.ENTITY_ACCOUNT_ID IS NULL
  AND ma.ACCOUNT_COUNT = 1;

-- For ambiguous mappings, choose the latest updated mapping by UPDATED_DTTM.
IF OBJECT_ID('tempdb..#MappingLatest') IS NOT NULL
  DROP TABLE #MappingLatest;

SELECT
  ranked.ENTITY_ID,
  ranked.SCOA_ACCOUNT_ID,
  ranked.ENTITY_ACCOUNT_ID
INTO #MappingLatest
FROM (
  SELECT
    mb.ENTITY_ID,
    mb.SCOA_ACCOUNT_ID,
    mb.ENTITY_ACCOUNT_ID,
    mb.UPDATED_DTTM,
    ROW_NUMBER() OVER (
      PARTITION BY mb.ENTITY_ID, mb.SCOA_ACCOUNT_ID
      ORDER BY COALESCE(mb.UPDATED_DTTM, '19000101') DESC, mb.ENTITY_ACCOUNT_ID ASC
    ) AS rn
  FROM #MappingBase mb
  INNER JOIN #MappingAgg ma
    ON ma.ENTITY_ID = mb.ENTITY_ID
    AND ma.SCOA_ACCOUNT_ID = mb.SCOA_ACCOUNT_ID
    AND ma.ACCOUNT_COUNT > 1
) ranked
WHERE ranked.rn = 1;

UPDATE esd
SET esd.ENTITY_ACCOUNT_ID = ml.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
INNER JOIN #MappingLatest ml
  ON ml.ENTITY_ID = esd.ENTITY_ID
  AND ml.SCOA_ACCOUNT_ID = esd.SCOA_ACCOUNT_ID
WHERE esd.ENTITY_ACCOUNT_ID IS NULL;

UPDATE edp
SET edp.ENTITY_ACCOUNT_ID = ml.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
INNER JOIN #MappingLatest ml
  ON ml.ENTITY_ID = edp.ENTITY_ID
  AND ml.SCOA_ACCOUNT_ID = edp.SCOA_ACCOUNT_ID
WHERE edp.ENTITY_ACCOUNT_ID IS NULL;

-- Review ambiguous mappings (multiple GL accounts per entity + SCoA).
SELECT
  ENTITY_ID,
  SCOA_ACCOUNT_ID,
  COUNT(DISTINCT ENTITY_ACCOUNT_ID) AS ACCOUNT_COUNT
FROM #MappingBase
GROUP BY ENTITY_ID, SCOA_ACCOUNT_ID
HAVING COUNT(DISTINCT ENTITY_ACCOUNT_ID) > 1
ORDER BY ENTITY_ID, SCOA_ACCOUNT_ID;

-- Review remaining NULLs in distribution tables after backfill.
SELECT
  esd.ENTITY_ID,
  esd.SCOA_ACCOUNT_ID,
  esd.DISTRIBUTION_TYPE,
  esd.PRESET_GUID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
WHERE esd.ENTITY_ACCOUNT_ID IS NULL
ORDER BY esd.ENTITY_ID, esd.SCOA_ACCOUNT_ID;

SELECT
  edp.ENTITY_ID,
  edp.SCOA_ACCOUNT_ID,
  edp.PRESET_GUID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
WHERE edp.ENTITY_ACCOUNT_ID IS NULL
ORDER BY edp.ENTITY_ID, edp.SCOA_ACCOUNT_ID;

ROLLBACK;
