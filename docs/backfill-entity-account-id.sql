-- Backfill ENTITY_ACCOUNT_ID for distribution tables using mapping presets.
-- Assumes these columns have been added:
--   ml.ENTITY_SCOA_DISTRIBUTION.ENTITY_ACCOUNT_ID
--   ml.ENTITY_DISTRIBUTION_PRESETS.ENTITY_ACCOUNT_ID
--
-- The backfill uses:
--   ml.ENTITY_ACCOUNT_MAPPING (ENTITY_ACCOUNT_ID, PRESET_GUID, ENTITY_ID)
--   ml.ENTITY_MAPPING_PRESET_DETAIL (PRESET_GUID, TARGET_DATAPOINT)
-- to map GL (ENTITY_ACCOUNT_ID) -> SCoA (TARGET_DATAPOINT).
--
-- Updates only when the mapping is unambiguous for an entity + SCoA pair.
BEGIN TRAN;

IF OBJECT_ID('tempdb..#MappingBase') IS NOT NULL
  DROP TABLE #MappingBase;

IF OBJECT_ID('tempdb..#MappingAgg') IS NOT NULL
  DROP TABLE #MappingAgg;

CREATE TABLE #MappingBase (
  ENTITY_ID varchar(36) NOT NULL,
  ENTITY_ACCOUNT_ID varchar(100) NOT NULL,
  PRESET_GUID varchar(36) NULL,
  UPDATED_DTTM datetime NULL,
  SCOA_ACCOUNT_ID varchar(max) NULL
);

IF EXISTS (
  SELECT 1
  FROM INFORMATION_SCHEMA.COLUMNS
  WHERE TABLE_SCHEMA = 'ml'
    AND TABLE_NAME = 'ENTITY_ACCOUNT_MAPPING'
    AND COLUMN_NAME = 'UPDATED_DTTM'
)
BEGIN
  INSERT INTO #MappingBase (
    ENTITY_ID,
    ENTITY_ACCOUNT_ID,
    PRESET_GUID,
    UPDATED_DTTM,
    SCOA_ACCOUNT_ID
  )
  SELECT DISTINCT
    eam.ENTITY_ID,
    eam.ENTITY_ACCOUNT_ID,
    eam.PRESET_GUID,
    eam.UPDATED_DTTM,
    NULLIF(LTRIM(RTRIM(emd.TARGET_DATAPOINT)), '') AS SCOA_ACCOUNT_ID
  FROM ml.ENTITY_ACCOUNT_MAPPING eam
  INNER JOIN ml.ENTITY_MAPPING_PRESET_DETAIL emd
    ON emd.PRESET_GUID = eam.PRESET_GUID
  WHERE eam.ENTITY_ACCOUNT_ID IS NOT NULL
    AND emd.TARGET_DATAPOINT IS NOT NULL;
END
ELSE
BEGIN
  INSERT INTO #MappingBase (
    ENTITY_ID,
    ENTITY_ACCOUNT_ID,
    PRESET_GUID,
    UPDATED_DTTM,
    SCOA_ACCOUNT_ID
  )
  SELECT DISTINCT
    eam.ENTITY_ID,
    eam.ENTITY_ACCOUNT_ID,
    eam.PRESET_GUID,
    NULL AS UPDATED_DTTM,
    NULLIF(LTRIM(RTRIM(emd.TARGET_DATAPOINT)), '') AS SCOA_ACCOUNT_ID
  FROM ml.ENTITY_ACCOUNT_MAPPING eam
  INNER JOIN ml.ENTITY_MAPPING_PRESET_DETAIL emd
    ON emd.PRESET_GUID = eam.PRESET_GUID
  WHERE eam.ENTITY_ACCOUNT_ID IS NOT NULL
    AND emd.TARGET_DATAPOINT IS NOT NULL;
END;

SELECT
  ENTITY_ID,
  SCOA_ACCOUNT_ID,
  MIN(ENTITY_ACCOUNT_ID) AS ENTITY_ACCOUNT_ID,
  COUNT(DISTINCT ENTITY_ACCOUNT_ID) AS ACCOUNT_COUNT
INTO #MappingAgg
FROM #MappingBase
WHERE SCOA_ACCOUNT_ID IS NOT NULL
GROUP BY ENTITY_ID, SCOA_ACCOUNT_ID;
UPDATE esd
SET esd.ENTITY_ACCOUNT_ID = ma.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
INNER JOIN #MappingAgg ma
  ON ma.ENTITY_ID = esd.ENTITY_ID
  AND ma.SCOA_ACCOUNT_ID = esd.SCOA_ACCOUNT_ID
WHERE esd.ENTITY_ACCOUNT_ID IS NULL
  AND ma.ACCOUNT_COUNT = 1;

UPDATE edp
SET edp.ENTITY_ACCOUNT_ID = ma.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
INNER JOIN #MappingAgg ma
  ON ma.ENTITY_ID = edp.ENTITY_ID
  AND ma.SCOA_ACCOUNT_ID = edp.SCOA_ACCOUNT_ID
WHERE edp.ENTITY_ACCOUNT_ID IS NULL
  AND ma.ACCOUNT_COUNT = 1;

-- For ambiguous mappings, choose the latest updated mapping by UPDATED_DTTM.
IF OBJECT_ID('tempdb..#MappingLatest') IS NOT NULL
  DROP TABLE #MappingLatest;

SELECT
  ranked.ENTITY_ID,
  ranked.SCOA_ACCOUNT_ID,
  ranked.ENTITY_ACCOUNT_ID
INTO #MappingLatest
FROM (
  SELECT
    mb.ENTITY_ID,
    mb.SCOA_ACCOUNT_ID,
    mb.ENTITY_ACCOUNT_ID,
    mb.UPDATED_DTTM,
    ROW_NUMBER() OVER (
      PARTITION BY mb.ENTITY_ID, mb.SCOA_ACCOUNT_ID
      ORDER BY COALESCE(mb.UPDATED_DTTM, '19000101') DESC, mb.ENTITY_ACCOUNT_ID ASC
    ) AS rn
  FROM #MappingBase mb
  INNER JOIN #MappingAgg ma
    ON ma.ENTITY_ID = mb.ENTITY_ID
    AND ma.SCOA_ACCOUNT_ID = mb.SCOA_ACCOUNT_ID
    AND ma.ACCOUNT_COUNT > 1
) ranked
WHERE ranked.rn = 1;

UPDATE esd
SET esd.ENTITY_ACCOUNT_ID = ml.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
INNER JOIN #MappingLatest ml
  ON ml.ENTITY_ID = esd.ENTITY_ID
  AND ml.SCOA_ACCOUNT_ID = esd.SCOA_ACCOUNT_ID
WHERE esd.ENTITY_ACCOUNT_ID IS NULL;

UPDATE edp
SET edp.ENTITY_ACCOUNT_ID = ml.ENTITY_ACCOUNT_ID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
INNER JOIN #MappingLatest ml
  ON ml.ENTITY_ID = edp.ENTITY_ID
  AND ml.SCOA_ACCOUNT_ID = edp.SCOA_ACCOUNT_ID
WHERE edp.ENTITY_ACCOUNT_ID IS NULL;

-- Review ambiguous mappings (multiple GL accounts per entity + SCoA).
SELECT
  ENTITY_ID,
  SCOA_ACCOUNT_ID,
  COUNT(DISTINCT ENTITY_ACCOUNT_ID) AS ACCOUNT_COUNT
FROM #MappingBase
GROUP BY ENTITY_ID, SCOA_ACCOUNT_ID
HAVING COUNT(DISTINCT ENTITY_ACCOUNT_ID) > 1
ORDER BY ENTITY_ID, SCOA_ACCOUNT_ID;

-- Review remaining NULLs in distribution tables after backfill.
SELECT
  esd.ENTITY_ID,
  esd.SCOA_ACCOUNT_ID,
  esd.DISTRIBUTION_TYPE,
  esd.PRESET_GUID
FROM ml.ENTITY_SCOA_DISTRIBUTION esd
WHERE esd.ENTITY_ACCOUNT_ID IS NULL
ORDER BY esd.ENTITY_ID, esd.SCOA_ACCOUNT_ID;

SELECT
  edp.ENTITY_ID,
  edp.SCOA_ACCOUNT_ID,
  edp.PRESET_GUID
FROM ml.ENTITY_DISTRIBUTION_PRESETS edp
WHERE edp.ENTITY_ACCOUNT_ID IS NULL
ORDER BY edp.ENTITY_ID, edp.SCOA_ACCOUNT_ID;

ROLLBACK;
